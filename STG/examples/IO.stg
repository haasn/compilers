{-
IO is treated as a free monad, ‘flattened’ here for simplicity:

> data IO a
>   = Return a
>   | forall i o. Run (FFI i o) (o -> IO a) i

Hidden implementation detail: FFI functions are built into the implementation
and not defineable or addressable within the language. Their corresponding
kleisli arrows can only be introduced via the special ‘extern’ construct.

> type FFI = (->)

-}

-- These should only ever be called by the RTS - in fact, ‘unsafeRealMain’
-- is the only thing the RTS ever calls. Technically these would be implemented
-- in the target language directly, but it's easier to just write them here.

unsafeRealMain = unsafeLoopIO main ;

unsafeLoopIO = \a -> a
  -- Return
  (const unsafeTermination)

  -- Run
  (\f n i ->
    let fi  = f i ;
        nfi = n fi ;

	-- Since ‘f’ has side effects, we need to force it for any IO to take
	-- place. This is factored out to a primitive function which also
	-- ensures that ‘fi’ is updated properly afterwards, so effects don't
	-- get repeated.
        ffi = ffiSeq fi nfi
    in unsafeLoopIO ffi)
;

-- Scott constructors

returnIO = \x     p r -> p x ;
runIO    = \f n i p r -> r f n i ;

-- Some I/O primitives and their corresponding tidied up versions

extern action <Console.Write> ;
extern func   <Console.ReadKey> ;
extern func   <(char)> ; -- Casts are treated the same as functions
extern field  <.KeyChar> ;
extern action <Environment.Exit> ;

putChar = \c -> bindIO (<(char)> c) <Console.Write> ;
getChar = bindIO (<Console.ReadKey> #true#) <.KeyChar> ;
exit    = <Environment.Exit> ;

-- Monadic binding primitives

bindIO = \x f -> x f (\p n -> runIO p (\o -> bindIO (n o) f)) ;

seqIO = \x y -> bindIO x (const y) ;

foreverIO = \a -> fix (seqIO a) ;

kleisliIO = \x y a -> bindIO (x a) y
