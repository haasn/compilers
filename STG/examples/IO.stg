{-
IO is treated as a free monad, ‘flattened’ here for simplicity:

> data IO a
>   = Return a
>   | forall i o. Run (FFI i o) i (o -> IO a)
>   | Exit Int

Hidden implementation detail. FFI functions are built into the
implementation and not defineable within the language. They are
prefixed by ‘unsafe’ to keep their name and intention recognizable.

> type FFI = (->)

> unsafePutChar :: FFI Char ()
> unsafeGetChar :: FFI () Char
> unsafeExit    :: FFI Int ()

Note: Char = Int internally
-}

-- These should only ever be called by the RTS - in fact, ‘unsafeRealMain’
-- is the only thing the RTS ever calls.

unsafeRealMain = unsafeLoopIO main ;

unsafeLoopIO = \a -> case a of {
  <0> x -> unsafeTermination

  <1> f i n ->
    let fi  = f i ;
        nfi = n fi ;

	-- Since ‘f’ has side effects, we need to force it for any IO to take
	-- place. This is factored out to a primitive function which also
	-- ensures that ‘fi’ is updated properly afterwards, so effects don't
	-- get repeated.
        ffi = seq fi nfi
    in unsafeLoopIO ffi

  <2> c -> unsafeExit c
};

-- The publicly accessible IO versions of the primitives

returnIO = \x -> <0> x ;

putChar = \c -> <1> unsafePutChar c returnIO ;

getChar = <1> unsafeGetChar unit returnIO ;

exit = \c -> <2> c ;

-- Monadic binding primitives

bindIO = \x f -> case x of {
  <0> a   -> f a
  <1> p i n -> <1> p i (\o -> bindIO (n o) f)

  -- Exit always terminates
  <2> c -> <2> c
};

seqIO = \x y -> bindIO x (const y) ;

foreverIO = \a -> fix (seqIO a)
