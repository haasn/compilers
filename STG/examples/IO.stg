{-
IO is treated as a free monad, ‘flattened’ here for simplicity:

> data IO a
>   = Return a
>   | forall i o. Run (FFI i o) i (o -> IO a)
>   | Exit Int

Hidden implementation detail. FFI functions are built into the
implementation and not defineable within the language. They are
prefixed by ‘unsafe’ to keep their name and intention recognizable.

> type FFI = (->)

> unsafePutChar :: FFI Char ()
> unsafeGetChar :: FFI () Char
> unsafeExit    :: FFI Int ()

Note: Char = Int internally
-}

-- These should only ever be called by the RTS - in fact, ‘unsafeRealMain’
-- is the only thing the RTS ever calls.

unsafeRealMain = unsafeLoopIO main ;

unsafeLoopIO = \a -> a
  -- Return
  (const unsafeTermination)

  -- Run
  (\f i n ->
    let fi  = f i ;
        nfi = n fi ;

	-- Since ‘f’ has side effects, we need to force it for any IO to take
	-- place. This is factored out to a primitive function which also
	-- ensures that ‘fi’ is updated properly afterwards, so effects don't
	-- get repeated.
        ffi = seq fi nfi
    in unsafeLoopIO ffi)

  -- Exit
  unsafeExit
;

-- Scott constructors

returnIO = \x p r e     -> p x ;
runIO    = \f i o p r e -> r f i o ;
exit     = \c p r e     -> e c ;

-- The publicly accessible IO versions of the primitives

putChar  = \c -> runIO unsafePutChar c    returnIO ;
getChar  =       runIO unsafeGetChar unit returnIO ;

-- Monadic binding primitives

bindIO = \x f -> x
  -- Return
  f

  -- Run
  (\p i n -> runIO p i (\o -> bindIO (n o) f))

  -- Exit always terminates
  exit
;

seqIO = \x y -> bindIO x (const y) ;

foreverIO = \a -> fix (seqIO a)
