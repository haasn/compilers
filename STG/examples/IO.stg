{-
IO is treated as a free monad, ‘flattened’ here for simplicity:

> data IOF a
>   = Return a
>   | forall i o. Run (FFI i o) (o -> IOF a) i

‘Run’ represents a call to an impure function (FFI i o), with a certain (pure)
input ‘i’, and a continatuon ‘o -> IO a’ that produces the final value, in
practice just ‘return’ for auto-lifted FFI actions.

To make things more efficient, the Codensity transformation is applied on top
of this base monad to form the actual IO.

> type IO a = forall b. (a -> IOF b) -> IOF b

----

Hidden implementation detail: FFI functions are built into the implementation
and not defineable or addressable within the language. Their corresponding
kleisli arrows can only be introduced via the special ‘extern’ construct.

> type FFI = (->)

.NET types are analogous to side-effectuous tuples, so in practice an impure
FFI primitive is () -> (), auto-lifted to the corresponding pure arrow of type
Kleisli IO () (). Since the church realization of () is ∀a. a -> a, operations
on .NET values (essentially references) simply push continuations on the stack.

-}

-- These should only ever be called by the RTS - in fact, ‘unsafeRealMain’
-- is the only thing the RTS ever calls. Technically these would be implemented
-- in the target language directly, but it's easier to just write them here.

unsafeRealMain = unsafeLoopIO (lowerIO main) ;

unsafeLoopIO = \a -> a
  -- Return
  (const unsafeTermination)

  -- Run
  (\f n i ->
    let fi  = f i

    -- Since ‘f’ has side effects, we need to force it for any IO to take
    -- place. This is factored out to a primitive function which also
    -- ensures that ‘fi’ is updated properly afterwards, so effects don't
    -- get repeated.
    in ffiSeq fi (unsafeLoopIO (n fi)))
;

-- Scott constructors

returnIOF = \x     p r -> p x ;
runIOF    = \f n i p r -> r f n i ;

-- Base monadic functions and codensity (un)lifting

bindIOF = \x f -> x f (\p n -> runIOF p (\o -> bindIOF (n o) f)) ;

lowerIO = \a -> a returnIOF ;

raiseIO = bindIOF ;

-- Lifted monadic functions

runIO = \f n i -> raiseIO (runIOF f n i) ;

returnIO = \a f -> f a ;

bindIO = \m f c -> m (\a -> f a c) ;

seqIO = \x y -> bindIO x (const y) ;

foreverIO = \a -> fix (seqIO a) ;

kleisliIO = \x y a -> bindIO (x a) y ;

-- Some example I/O primitives

extern action exit    { Environment.Exit (it)        } ;
extern action print   { Console.WriteLine (it)       } ;
extern action putChar { Console.Write ((char) it)    } ;
extern func   readKey { Console.ReadKey (it).KeyChar } ;

getChar = readKey #true#
